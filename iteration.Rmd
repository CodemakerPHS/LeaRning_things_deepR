---
title: "![](img/header.png) Intermediate R"
author: "Brendan Clarke"
date: "`r Sys.Date()`"
always_allow_html: true
output:
  html_document: 
    toc_depth: 2
    toc_float:
      collapsed: no
    fig_width: 6
    fig_height: 2
  word_document:
    toc: yes
    toc_depth: '2'
  pdf_document:
    toc: yes
    toc_depth: '2'
    pandoc_args: ["--extract-media", "."]
editor_options: 
  chunk_output_type: console
---

```{r echo=F}
knitr::opts_chunk$set(echo = TRUE, warning = F, message = F)
install.packages(setdiff("pacman", rownames(installed.packages())))
library("pacman")
p_load(tidyr,readr,DiagrammeR,ggplot2,dplyr,lubridate,NHSRplotthedots,readxl,stringr,NHSRdatasets, purrr, rlang,glue)
```

# Iteration {.tabset}
Iteration describes a section of code that is repeatedly run. The best example is a for-loop. For-loops run *for* a set number of repetitions. An example in pseudocode:

```
for (1 to 10) 
  run some bit of code here 10 times
  
...and move on only when complete
```
While for-loops are a basic building-block of many programming languages, they are found infrequently in R. There are a couple of good reasons for this. First, for-loops can be very slow in R, and writing high-performance code has a perennial appeal that surpasses its actual importance in day-to-day data analysis. Second, most functions in R are vectorised (a term we'll explain later). For now, all we need to know is that vectorised functions allow a user to avoid writing for-loops.

However, imperative programming using for-loops definitely has a place, even if a purist might avoid them for performance reasons. Computer time is cheaper than analyst time, and loops definitely have some strengths in real-world analysis. One important strength of for-loops is that they allow you to repeatedly apply a non-vectorised functions elegantly. As some of the core Rmarkdown functions are not vectorised, for-loops are an important part of the Rmarkdown programmer's toolkit. So this training will give you a basic introduction to writing good loops in R, and we'll cover some strategies for avoiding the worst of the performance hit that iteration can cause to your work.

This training session is part of a wider training programme designed as next steps for R users who have moved beyond introductory training. This programme covers:

+ tidy evaluation
+ functions
+ dplyr
+ purr

This iteration training can be taken as a stand-alone session, or integrated into a more involved programme with the other sessions. You can find further details on the [TURAS page](), join the [KIND Learning Network](https://forms.office.com/r/WQdd6HSCEW) for social learning support, or contact [Brendan Clarke](mailto: brendan.clarke2@nhs.scot?subject=[purrr training]) with any queries, comments, or suggestions.

## Introduction

Once again, this training is influenced by the explanations and code from [R4DS](https://r4ds.had.co.nz/iteration.html#for-loops). It's impossible to recommend this book as a resource too strongly, and a quick read of the iteration chapter will be a useful adjunt to this session.

Note too that there's a bit more base R in this session than most of the KIND Learning Network training. This might introduce a bit of unfamiliar code, but we'll explain anything new that crops up, and most of the base R code is pretty straightforward. A couple of examples right away. For some tibble called `df`:

+ `df[[]]`
  + `df[["val"]]` selects the column named `val` 
  + `df[[n]]` selects the nth column from df
+ `df$`
  + `df$val` selects the column named `val` 
  + `df$n` selects the nth column from df

`setdiff()` is very helpful to check what you're selecting:

```{r}
setdiff(synthetic_news_data[["age"]], synthetic_news_data[[2]])

setdiff(synthetic_news_data %>% select(age) %>% pull(), synthetic_news_data[[2]])
```

## For-loops

Let's begin with a simple example:

```{r}

word <- ""

x <- 1:10

for (i in seq_along(x)) {
  word[[i]] <- "iteration is"
}

cat(word)
```

From the [R4DS chapter](https://r4ds.had.co.nz/iteration.html) which - like the rest of that book - is essential reading, we can identify three parts to this for loop:

1. **Output** - what do you want out of the loop? Here, it's `word`, which is initially empty, but will gradually expand...
2. **Sequence** - what do you want to loop over? Here, it's `x`, which contains the numbers 1 to 10
3. **Body** - what do you want the loop to do? Writing the code is easier than explaining it, but the parts here are:
    + first, we have `for()` which starts the loop
    + next, inside the `for()` function, we take the first value of `x`, and store it in `i`
    + we then add the phrase "iteration is" into the `i`th position of the `word` vector
    + finally, we replace the current value of `i` with the next item in the sequence `x`, and re-run the code above. This goes on until we reach the end of the sequence `x`
    
This might be a bit more obvious if we tweak our code to include the value of `i` before each element we add into the `word` vector:
  
```{r}

word <- ""

x <- 1:10

for (i in seq_along(x)) {
  word[[i]] <- glue("iteration {i}")
}

cat(word)
```

And there's no reason we need to confine the output of our loop to a vector. We could adapt our loop to produce a simple tibble:

```{r}

words <- tibble(iteration="",contents="")

x <- 1:5
for (i in seq_along(x)) {
  words[i, 1] <- as.character(i)
  words[i, 2] <- glue("iteration {i}")
}
words %>%
  knitr::kable()
```

### Exercises

Let's take that first loop, and tweak it. Can you make the loop count from 1 to 10, so that `word` contains 1,2,3...? I've started you off with the original code:

```{r results='asis'}
word <- ""

x <- 1:10

for (i in seq_along(x)) {
  word[[i]] <- "iteration is"
}

cat(word)
```


```{r results='asis'}

```

Can you now reverse the order, so that `word` contains 10,9,8...?

```{r results='asis'}

```

Finally, can you use the `glue()` function so that this function prints the lyrics of "Ten Green Bottles"?

```{r results='asis'}

```

## Output

One reason that many R programmers will avoid writing loops concerns performance. And there are some good reasons that loops in R are rather slower than some of the alternative ways of working. I think the first piece of useful advice here is that performance should be fairly low down on your list of concerns as someone working in R. Computer time is cheap - much cheaper than your time spent optimising performance. Exceptions obviously apply, particularly if you're writing code that will be widely and repeatedly used. That said, there are some quick and easy ways of speeding up code with loops if you need to. The most important lesson here is:

+ **never grow your output in the body of the loop**

In this section, we'll also look at benchmarking using `microbenchmark()` as a way of assessing performance. Let's have a very quick look at that now, and then we'll use the same syntax to compare a couple of approaches to building output in loops.

```{r}
library(microbenchmark)

mbm <- microbenchmark(multiplication={2*2*2}, addition = {2+2+2+2}, power = 2^3)
autoplot(mbm)

```

`microbenchmark()` shows processing time for repeated runs of an operation, and then plotting the results. Let's use it to look at the performance of a simple loop:

```{r cache=TRUE}
mbm <- microbenchmark(loop={
  
  x<-1:1000
  output <- vector("integer", length(x))
  
  for (i in seq_along(x)) {
    output[[i]] <- i^2
  }

})

autoplot(mbm)
```

That seems snappy enough - although running it a hundred times for the benchmark does slow down the knitting process, which is why the results for this section are cached.

Now let's compare two versions of the same loop - one which sets the length of the output, then assigns the results to the ith position of the output, and the other which creates an empty vector, and then just collapses each new piece of output to the end of it:

```{r cache=TRUE}
mbm <- microbenchmark(loop={
  
  x<-1:1000
  output <- vector("integer", length(x)) # an empty vector the same length as our intended output

  for (i in seq_along(x)) {
    output[[i]] <- i^2
  }

}, loop_short_output={

  x<-1:1000
  output_2 <- vector("integer", 0) # just an empty vector

  for (i in seq_along(x)) {
    output_2 <- c(output_2, i^2)
  }

})

autoplot(mbm)
```

The outputs are identical:
```{r}
setdiff(output, output_2)
```

Okay, so in this example the time saved is minimal - a few milliseconds. But when the output is bigger - like iteratively adding rows to a tibble - the time taken to knit your code can be a serious problem. Creating a sensibly-sized container for your output at the start of the loop, and then filling that container by indexing, is simple enough to do, and can help your loops run rapidly.

## Sequences

This section gives some tips for efficiently generating sequences, and then using them safely in loops. The obvious place to start are the base-R methods of using either `c()`, or `:` to produce ranges:

```{r}
c(1,2,3,4)
1:10
```

R also comes with a few useful built-in sequences:

```{r}
letters 
LETTERS
month.abb
```

A common job is generating a sequence from some data. This can easily be done in base R:

```{r eval=F}
sort(unique(ae_attendances$org_code)) # giving a sorted list of all values in a column
```
(not run here, because it's really long!)

You can also subset this using an index range:

```{r}
sort(unique(ae_attendances$org_code))[1:10] # giving a sorted list of the first 10 values in a column
```
  
```{r}
colnames(ae_attendances) # giving column names
```

As you might expect, the tidyverse versions are easier to understand but rather longer:

```{r}
synthetic_news_data  %>%
  distinct(NEWS) %>%
  pull() %>%
  sort()
```

Now that we've covered a few ways of generating sequences, we can also dip into some methods for working through seqeuences, as you might do while setting up your loop. `seq_along()` cycles through a sequence numerically:

```{r}
seq_along(synthetic_news_data) # cycles through the columns of a tibble

seq_along(letters) # seq_along() also works with vectors etc
```

You can use `names()` to cycle through sequences by column name:
```{r}
names(synthetic_news_data) # cycles through the sequence by column name (tibbles / data frames only)
```

It's generally best to avoid rownames if at all possible, but there is also a `rownames()` function that might be needed while working with unusual or transposed data:

```{r}
t(synthetic_news_data) %>%
  rownames()
```

## Vectorised functions

Most functions in R are vectorised. That means that:

+ they can take a vector as input
+ they will then work over that vector, and return a vector as output

That's even the case when we haven't tried to make a function work in a vectorised way. For instance, we can sling together a tiny function:

```{r}
cube <- function(num) {num ^3}
```

And then when we call it over a vector, we get vectorised output:
```{r}
cube_inputs <- c(3,6,5,4,3)
cube(cube_inputs)
```

So what's the problem? Let's fiddle with our `cube()` function:

```{r}
conditional_cube <- function(num) {
  if(num %% 2 == 0) {
    num ^ 3 }
  else {
    num ^ 2 }
}
```

The updated function works perfectly on single digits:

```{r}
conditional_cube(3) # should square the input for odd numbers
conditional_cube(4) # should cube the input for even numbers
```

This now won't work on a vector:

```{r eval=F}
conditional_cube(cube_inputs)
```

`conditional_cube()` is therefore described as a scalar function. There really aren't that many scalar functions in widespread use now, but it's a fairly common (and irritating) little problem to run into while writing your own functions. The part of `conditional_cube()` that's causing a problem for us is the if/then statement.

We can solve this in a couple of different ways:

1. we can use the `Vectorize()` - with a capital V - function as a wrapper for our function:

```{r}
vector_conditional_cube <- Vectorize(conditional_cube)
vector_conditional_cube(cube_inputs)
```

2. we can re-build our function so that it no longer depends on a scalar function. So we can replace `if()`/`else()` with the vectorised `ifelse()`:

```{r}
ifelse_conditional_cube <- function(num){
  ifelse(num %% 2 == 0, num^3, num^2 )
}

ifelse_conditional_cube(cube_inputs)
```

3. (and the reason for this apparent digression here) we can just loop over the scalar function, and not bother to re-work it at all:

```{r}
cube_outputs <- vector("double", length(cube_inputs))

for(i in seq_along(cube_inputs)) {
  cube_outputs[[i]] <- conditional_cube(cube_inputs[[i]])
}

cube_outputs
```

Okay, so it seems like writing a loop isn't worth the trouble for a really simple function like `cube()`. Let's use a slightly more complicated function to demonstrate where that trade-off might feel rather different.

Here's our function, `perd()`:
```{r}
perd <- function(x) {
  glue("This value here is {x}")
}
```

Let's try `perd()` out inside `mutate()`:

```{r}
synthetic_news_data %>%
  mutate(age = perd(age))
```

So what happens when we try to use this function across everything?

```{r}
synthetic_news_data %>%
  mutate(across(everything(), perd))
```

That works straightforwardly enough, even if it ruins our tibble completely. Things get a bit more complicated when we try to add extra arguments to `perd()` though:

```{r}
perd_v <- function(var_name, x) {
  glue("This value of {var_name} here is {x}")
}
```

We can use dplyr's [context dependent expressions](https://dplyr.tidyverse.org/reference/context.html) here:

```{r}
synthetic_news_data %>%
  mutate(across(everything(), ~ perd_v(cur_column(),.)))
```

But, particularly as a beginner, this kind of syntax is hard to write and understand. A simpler option is to use a loop to do this reworking;

```{r}
output <- synthetic_news_data
x <- names(output)

for (i in seq_along(x)) {
  output[[i]] <- perd_v(names(output[i]), output[[i]])
}
glimpse(output[1,])

```

## Rmarkdown with loops {.tabset}

### Introduction

One area where loops excel is generating a mixture of R and Rmarkdown. We'll demonstrate an example of this in the next subsection. This loop uses the attendances data from the `ae_attendances` dataset, which looks like this:

```{r}
ae_attendances %>%
  slice(1:5) %>%
  knitr::kable()
```

The aim here is to demonstrate how to write a loop that performs the same bit of analysis for each of the orgs in the data, and inserts that bit of analysis for one org into a separate Rmarkdown subsection. This is a great way of standardising and organising your report - we write the code once only, and then use the loop to run it over different values of org_code. In a bit more detail, our loop will:

+ set up a sequence composed of each of the org_codes in the data
  + actually, I will cheat here. There are 274 orgs in the dataset, and so we'll just look at a random sample of 10 to avoid making a document that takes an eternity to knit.
+ we'll then loop over that sequence, and for each org code it will:
  + print an Rmarkdown header in a new subsection tab
  + print a little bit of explanatory text
  + print a table summarising the admissions data for that organisation
  + display a small graph, showing how the total admissions for that organisation compares with the other 273 orgs in the data

Let's look at the example first, with no code, and then we'll work through each of the stages above to explain how all of the parts fit together.

### Example {.tabset}
```{r loop-ex, echo=F, fig.height=1.5, fig.width=4, results='asis'}
# worth looking at the chunk headers for the example and explanation. We don't repeat the code in this section, but we just re-use the example chunk with different chunk options to show the code rather than the output. https://bookdown.org/yihui/rmarkdown-cookbook/reuse-chunks.html is a good place to start if this is of interest.

# note that our loop just displays things in our document, so we don't bother to create an output here

# create a vector of sample orgs to simplify the for() call and filter() indirection later on
orgs_seq <- as.character(sample(ae_attendances %>% 
                                  distinct(org_code) %>% 
                                  arrange(org_code) %>% 
                                  pull(), 10)
                         ) 

# print a single header message outside the body of the loop telling the reader what to expect
cat(glue("In this section we present a summary of admissions data, grouped by type of admission, for a sample of {length(orgs_seq)} organisations.  \n")) 

# set up the main body of the loop
for (i in seq_along(orgs_seq)) {
  
    # calculating the total admissions for our org - we use this in the explanatory text, and in the graph
    org_total_admissions <- ae_attendances %>%
            filter(org_code == orgs_seq[i]) %>%
            summarise(sum(attendances)) %>%
            pull()
    
    # customised 4th level header containing org_code
    cat(paste0("  \n  \n#### ", orgs_seq[i], " attendances  \n"))
    
    # customised explanatory text
    cat(paste0("Some explanatory text: ", orgs_seq[i], " had a total of ", org_total_admissions, " admissions.  \n"))
    
    # use kable() to display a summary of the data
    print(ae_attendances %>%
      drop_na(org_code) %>%
      filter(org_code == orgs_seq[i]) %>%
      group_by(type) %>%
      summarise(attendances = sum(attendances)) %>%
      knitr::kable()
      )
    
    cat("  \n") # otherwise the graph won't print - see https://github.com/yihui/knitr/issues/886
    
    # histogram of admissions across orgs, for comparison
    print(ae_attendances %>%
      group_by(org_code) %>%
      summarise(attendances = sum(attendances)) %>%
      ggplot() +
      geom_histogram(aes(x=attendances), bins=10) +
      geom_vline(xintercept=org_total_admissions) +
      xlab("Total admissions") +
      ylab("n orgs") +
      geom_label(aes(x=org_total_admissions, y=60), label = paste0(org_total_admissions, " total"), nudge_x = 0.35, size = 3)) + # label showing value of admissions for this org
      xlim(0,2000000) #little cheat to keep the label from being cut off for very high values

    cat("\n") # absolutely essential - see https://github.com/yihui/knitr/issues/886
}

```

### Explanation
```{r, loop-ex, eval=F}
```

### Exercise

We're going to update the example in this exercise. We want to make the following changes:

+ instead of a random sample of org_codes, we want to look at all the orgs where attendances is greater than 800000
+ ...and let's rank our orgs in terms of their total attendances, and use that ranking as the sequence for our loop
+ We'll also display rankings in the explanatory text
+ instead of plotting the total attendance on a histogram, we want to look at the three types of attendance separately
+ we want to be a bit more ambitious with our table. Can we update the table so that we get a percentage rate for each of the types of admission?

This is a bit of a jigsaw puzzle. I've put the working code snippets into the chunk below, and we'll work through assembling them into a working loop.

```{r fig.height=1.5, fig.width=4, results='asis'}
orgs <- ae_attendances %>%
  group_by(org_code) %>%
  summarise(attendances = sum(attendances)) %>%
  filter(attendances > 800000) %>%
  mutate(rank = rank(desc(attendances))) %>%
  arrange(rank) %>%
  pull(org_code)

one_org <- ae_attendances %>%
      group_by(org_code, type) %>%
      summarise(attendances = sum(attendances)) %>%
      filter(org_code == "RAS")

one_org %>%
  mutate(attendances = glue("{attendances} ({100*(round(attendances / sum(attendances), 3))}% of total)")) %>%
  knitr::kable()

ae_attendances %>%
      group_by(org_code, type) %>%
      summarise(attendances = sum(attendances)) %>%
      ggplot() +
      geom_histogram(aes(x=attendances, fill=type), bins=10) +
      geom_vline(data = one_org, aes(xintercept=attendances), color=c("#000099")) +
      facet_wrap(~type) +
      xlab("Total admissions") +
      ylab("n orgs") +
      theme(legend.position="none", axis.text.x = element_blank(), axis.ticks.x = element_blank())
```